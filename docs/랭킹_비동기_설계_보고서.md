# 랭킹 및 비동기 처리 디자인 설계 보고서

## 📋 개요

이커머스 플랫폼의 성능 최적화와 사용자 경험 향상을 위해 Redis 기반의 실시간 랭킹 시스템과 비동기 처리 아키텍처를 설계 및 구현하였습니다.

---

## 1. 실시간 상품 랭킹 시스템

### 1.1 요구사항

-   실시간으로 주문 수량 기반 인기 상품 랭킹 제공
-   일간/주간 기준별 랭킹 조회
-   빠른 응답 속도 (ms 단위)
-   수평 확장 가능한 구조

### 1.2 기술 선택

| 요소        | 선택                              | 선택 이유                                                  |
| ----------- | --------------------------------- | ---------------------------------------------------------- |
| **저장소**  | Redis Sorted Set (ZSET)           | O(log N) 시간복잡도로 점수 기반 정렬, 실시간 업데이트 지원 |
| **키 구조** | `product:ranking:{period}:{date}` | 기간별 분리로 효율적인 TTL 관리                            |
| **TTL**     | Daily 30일, Weekly 12주           | 적절한 데이터 보존 기간 설정                               |

### 1.3 아키텍처

```
┌─────────────┐     ┌──────────────┐     ┌─────────────────┐
│   주문 생성  │ --> │ OrderEvent   │ --> │ ProductRanking  │
│   (Order)   │     │   Listener   │     │    Service      │
└─────────────┘     └──────────────┘     └────────┬────────┘
                                                   │
                                                   v
                                          ┌───────────────┐
                                          │ Redis ZSET    │
                                          │ (Sorted Set)  │
                                          └───────────────┘
```

### 1.4 핵심 구현

```kotlin
// Redis ZSET을 활용한 랭킹 점수 증가
zSetOps.incrementScore(key, productId.toString(), quantity.toDouble())

// 상위 N개 랭킹 조회 (내림차순)
zSetOps.reverseRangeWithScores(key, 0, (limit - 1).toLong())
```

### 1.5 키 설계

| 기간   | 키 포맷                                 | 예시                              |
| ------ | --------------------------------------- | --------------------------------- |
| Daily  | `product:ranking:daily:{yyyyMMdd}`      | `product:ranking:daily:20241204`  |
| Weekly | `product:ranking:weekly:{year}-W{week}` | `product:ranking:weekly:2024-W49` |

---

## 2. 비동기 처리 아키텍처

### 2.1 이벤트 기반 비동기 처리

#### 처리 대상

| 이벤트                    | 비동기 작업                  | 처리 방식                                |
| ------------------------- | ---------------------------- | ---------------------------------------- |
| **OrderCreatedEvent**     | 장바구니 삭제, 랭킹 업데이트 | `@Async` + `@TransactionalEventListener` |
| **PaymentCompletedEvent** | 데이터 플랫폼 전송           | `@Async` + `@TransactionalEventListener` |

#### 아키텍처 다이어그램

```
┌──────────────────────────────────────────────────────────────────┐
│                        주문/결제 흐름                              │
└──────────────────────────────────────────────────────────────────┘

[OrderService]                           [PaymentService]
     │                                         │
     │ publishEvent(OrderCreatedEvent)         │ publishEvent(PaymentCompletedEvent)
     v                                         v
┌─────────────────┐                    ┌─────────────────┐
│ OrderEvent      │                    │ PaymentEvent    │
│ Listener        │                    │ Listener        │
│ @Async          │                    │ @Async          │
│ @AfterCommit    │                    │ @AfterCommit    │
└────────┬────────┘                    └────────┬────────┘
         │                                      │
    ┌────┴────┐                                 v
    v         v                         ┌───────────────┐
┌───────┐ ┌───────┐                     │ DataPlatform  │
│ Cart  │ │Ranking│                     │   Service     │
│Delete │ │Update │                     │ (Outbox)      │
└───────┘ └───────┘                     └───────────────┘
```

#### 핵심 코드

```kotlin
@Async("taskExecutor")
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
fun handleOrderCreated(event: OrderCreatedEvent) {
    // 트랜잭션 커밋 후 비동기로 실행
    updateProductRanking(event)
    deleteUserCart(event)
}
```

### 2.2 선착순 쿠폰 발급 (Redis Queue 기반)

#### 요구사항

-   대량의 동시 요청 처리 (선착순)
-   재고 초과 발급 방지
-   중복 발급 방지
-   시스템 안정성 확보

#### 아키텍처

```
┌─────────────────────────────────────────────────────────────────────┐
│                     선착순 쿠폰 발급 흐름                              │
└─────────────────────────────────────────────────────────────────────┘

  [API Request]
       │
       v
  ┌──────────────────────────────────────────────────┐
  │            requestCouponIssuance()               │
  │  ┌─────────────────────────────────────────────┐ │
  │  │ 1. 중복 검증 (Redis Set)                    │ │
  │  │    SISMEMBER coupon:{id}:users {userId}    │ │
  │  ├─────────────────────────────────────────────┤ │
  │  │ 2. 재고 검증 (Redis Counter)                │ │
  │  │    INCR coupon:{id}:count                  │ │
  │  ├─────────────────────────────────────────────┤ │
  │  │ 3. Queue 적재 & Set 등록                    │ │
  │  │    SADD coupon:{id}:users {userId}         │ │
  │  │    RPUSH coupon:issue:queue {couponId}:{userId} │ │
  │  └─────────────────────────────────────────────┘ │
  └──────────────────────────────────────────────────┘
       │
       │ 즉시 응답 (QUEUED)
       v
  [Client]

              ─────────────────────────────────────

  ┌──────────────────────────────────────────────────┐
  │          CouponIssueScheduler                    │
  │          @Scheduled(fixedDelay = 500)           │
  │  ┌─────────────────────────────────────────────┐ │
  │  │ 1. Queue에서 메시지 꺼내기 (LPOP)            │ │
  │  ├─────────────────────────────────────────────┤ │
  │  │ 2. 실제 DB 발급 처리                         │ │
  │  │    issueCoupon() + @DistributedLock         │ │
  │  ├─────────────────────────────────────────────┤ │
  │  │ 3. 실패 시 DLQ 이동                          │ │
  │  │    RPUSH coupon:issue:dlq {message}         │ │
  │  └─────────────────────────────────────────────┘ │
  └──────────────────────────────────────────────────┘
```

#### Redis 데이터 구조

| 키                   | 타입             | 용도                         |
| -------------------- | ---------------- | ---------------------------- |
| `coupon:{id}:count`  | String (Counter) | 발급 수량 카운트             |
| `coupon:{id}:users`  | Set              | 발급 사용자 목록 (중복 방지) |
| `coupon:issue:queue` | List             | 발급 요청 대기열             |
| `coupon:issue:dlq`   | List             | Dead Letter Queue            |

#### 실패 처리 전략

```kotlin
when (e) {
    is CouponAlreadyIssuedException -> {
        // 이미 발급됨: 무시 (재시도 불필요)
        logger.warn("Coupon already issued")
    }
    is CouponOutOfStockException -> {
        // 재고 소진: 무시 (재시도 불필요)
        logger.warn("Coupon out of stock")
    }
    else -> {
        // 시스템 오류: DLQ로 이동하여 추후 재처리
        redisTemplate.opsForList().rightPush(dlqKey, message)
    }
}
```

### 2.3 데이터 플랫폼 전송 (Outbox Pattern)

#### 요구사항

-   결제 완료 후 외부 시스템에 데이터 전송
-   전송 실패 시 재시도 가능
-   원본 트랜잭션에 영향 없음

#### 구현 방식

```kotlin
@Transactional(propagation = Propagation.REQUIRES_NEW)
override fun sendPaymentData(event: PaymentCompletedEvent) {
    try {
        val isSuccess = mockExternalApiCall(event)

        if (isSuccess) {
            saveTransmissionLog(orderId, TransmissionStatus.SUCCESS, "Success")
        } else {
            saveTransmissionLog(orderId, TransmissionStatus.FAILED, "API failed")
        }
    } catch (e: Exception) {
        saveTransmissionLog(orderId, TransmissionStatus.FAILED, e.message)
    }
}
```

#### DataTransmission 엔티티

```kotlin
DataTransmission(
    orderId = orderId,
    status = TransmissionStatus.FAILED,
    errorMessage = "Connection timeout",
    attempts = 1,
    maxAttempts = 3,
    nextRetryAt = LocalDateTime.now().plusMinutes(5)
)
```

---

## 3. 설계 결정 및 트레이드오프

### 3.1 이벤트 리스너 위치 결정

| 옵션              | 장점                    | 단점                    | 결정    |
| ----------------- | ----------------------- | ----------------------- | ------- |
| Domain Layer      | 도메인 순수성 유지      | Application 의존성 발생 | ❌      |
| Application Layer | 서비스별 분리 가능      | 도메인 간 조율 복잡     | ❌      |
| **Common Layer**  | 크로스 도메인 조율 용이 | 공통 모듈 비대화 가능   | ✅ 선택 |

**결정 이유**: `OrderEventListener`가 Cart, Ranking, DataPlatform 등 여러 도메인을 조율하므로, 특정 도메인에 종속되지 않는 Common Layer가 적합

### 3.2 비동기 처리 방식 비교

| 방식                        | 사용 시점                | 장점                   | 단점                        |
| --------------------------- | ------------------------ | ---------------------- | --------------------------- |
| **@Async + EventListener**  | 랭킹 업데이트, 카트 삭제 | 구현 간단, Spring 통합 | 대량 처리 시 스레드 풀 한계 |
| **Redis Queue + Scheduler** | 선착순 쿠폰 발급         | 순서 보장, 재시도 용이 | 구현 복잡도 증가            |
| **Outbox Pattern**          | 데이터 플랫폼 전송       | 신뢰성 높음, 감사 로그 | DB 부하 증가                |

### 3.3 분산락 설정

```kotlin
@DistributedLock(
    key = "'coupon:issue:' + #couponId",
    waitTimeMs = 3000,      // 락 대기 시간
    leaseTimeMs = 10000,    // 락 점유 시간
    unlockAfterCommit = true // 트랜잭션 커밋 후 해제
)
```

**`unlockAfterCommit = true` 선택 이유**: 트랜잭션이 커밋되기 전에 락이 해제되면, 다른 요청이 아직 커밋되지 않은 데이터를 읽을 수 있어 데이터 정합성 문제 발생 가능

---

## 4. 테스트 전략

### 4.1 테스트 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                        테스트 피라미드                            │
└─────────────────────────────────────────────────────────────────┘

                    ┌───────────────┐
                    │  Integration  │  DataPlatformServiceIntegrationTest
                    │    Tests      │  CouponAsyncIssuanceIntegrationTest
                    └───────┬───────┘
                            │
              ┌─────────────┴─────────────┐
              │         Unit Tests        │  CouponIssueSchedulerUnitTest
              │                           │  PaymentEventListenerUnitTest
              │                           │  DataPlatformServiceUnitTest
              └───────────────────────────┘
```

### 4.2 통합 테스트 구성

| 테스트                                 | 검증 항목                                |
| -------------------------------------- | ---------------------------------------- |
| `CouponAsyncIssuanceIntegrationTest`   | Redis Queue 적재, 재고 관리, 동시성 처리 |
| `DataPlatformServiceIntegrationTest`   | 이벤트 발행, DataTransmission 저장       |
| `ProductRankingServiceIntegrationTest` | ZSET 저장/조회, TTL 설정                 |

### 4.3 테스트 환경

-   **Embedded Redis**: 테스트 격리를 위한 내장 Redis
-   **H2 Database**: 인메모리 DB로 빠른 테스트 실행
-   **@DataJpaTest**: JPA 레이어 테스트에 최적화

---

## 5. 회고

### 5.1 잘된 점 ✅

1. **관심사 분리**: 이벤트 기반 아키텍처로 도메인 간 결합도 최소화
2. **장애 격리**: 비동기 처리로 부수 작업 실패가 핵심 기능에 영향 없음
3. **확장성**: Redis 기반 설계로 수평 확장 용이
4. **재시도 가능**: DLQ 및 Outbox 패턴으로 실패 복구 용이
5. **테스트 용이성**: 단위 테스트와 통합 테스트 분리로 테스트 커버리지 향상

### 5.2 개선이 필요한 점 ⚠️

1. **DLQ 처리 자동화**: 현재 DLQ 메시지는 수동 처리 필요 → 자동 재처리 배치 필요
2. **모니터링**: Redis Queue 길이, 처리 지연 시간 등 메트릭 수집 필요
3. **Circuit Breaker**: 외부 시스템 장애 시 빠른 실패 처리 필요
4. **테스트 환경 한계**: `@DataJpaTest`에서 `@Async` 이벤트 리스너 미동작 → 별도 테스트 전략 필요

### 5.3 향후 개선 계획

| 영역        | 개선 사항                            | 우선순위 |
| ----------- | ------------------------------------ | -------- |
| 모니터링    | Prometheus + Grafana 대시보드 구축   | 높음     |
| 장애 대응   | Resilience4j Circuit Breaker 적용    | 높음     |
| DLQ 처리    | 자동 재처리 스케줄러 구현            | 중간     |
| 성능 테스트 | K6/Gatling 부하 테스트 시나리오 작성 | 중간     |
| 알림        | 실패율 임계치 초과 시 Slack 알림     | 낮음     |

---

## 6. 결론

Redis 기반의 실시간 랭킹 시스템과 이벤트 기반 비동기 처리 아키텍처를 통해:

-   **응답 속도 향상**: 부수 작업을 비동기로 분리하여 API 응답 시간 단축
-   **시스템 안정성**: 장애 격리 및 재시도 메커니즘으로 신뢰성 확보
-   **확장성**: 대량 트래픽에도 유연하게 대응 가능한 구조 구축

향후 모니터링 강화와 장애 대응 체계 보완을 통해 더욱 견고한 시스템으로 발전시킬 계획입니다.

---
